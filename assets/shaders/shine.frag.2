uniform float u_time;
uniform vec2 u_resolution;
uniform float u_intensity = 0.9;
uniform vec2 u_mouse ;
uniform float u_mouse_sensitivity = 0.5; // Add this at the top
uniform float u_scale = 2.0; // Add this uniform

float easeInSine(float x) {
  return 1 - cos((x * 3.14159) / 2);
}

vec4 effect(vec4 color, Image texture, vec2 texCoords, vec2 screenCoords) {
    vec4 baseColor = Texel(texture, texCoords);

    // Apply perspective distortion to texture coordinates
    if (u_mouse.x >= 0.0) {
        // Same tilt calculation as position function
        float tiltStrength = 1.2;
        float tiltX = -(u_mouse.y - 0.5) * tiltStrength;
        float tiltY = (u_mouse.x - 0.5) * tiltStrength;

        // Convert texture coords to -0.5 to 0.5 range
        vec2 centered = texCoords - 0.5;

        // MUCH smaller perspective effect to avoid going out of bounds
        float perspectiveX = 1.0 - centered.y * tiltX * 0.1; // Reduced from 0.3
        float perspectiveY = 1.0 - centered.x * tiltY * 0.1; // Reduced from 0.3

        vec2 perspectiveCoords = vec2(
            centered.x * perspectiveX,
            centered.y * perspectiveY
        ) + 0.5;

        // Check if coordinates are in valid range, if not use original
        if (perspectiveCoords.x >= 0.0 && perspectiveCoords.x <= 1.0 &&
            perspectiveCoords.y >= 0.0 && perspectiveCoords.y <= 1.0) {
            baseColor = Texel(texture, perspectiveCoords);
        } else {
            baseColor = Texel(texture, texCoords); // Fallback to original
        }
    } else {
        baseColor = Texel(texture, texCoords);
    }

    if (u_mouse.x < 0.0) {
        return vec4(baseColor.rgb, baseColor.a);
    }


    float diagonal = texCoords.x + texCoords.y;
    float speed = 2.0;

    // Add time-based randomness to spacing and positions
    float timeVar1 = sin(u_time * 0.4) * 0.2;
    float timeVar2 = cos(u_time * 0.3) * 0.2;
    float timeVar3 = sin(u_time * 0.5 + 1.5) * 0.2;

    // Calculate three band positions with slightly randomized spacing
    float baseSpacing = 0.67; // Base spacing between bands (2.0/3)
    float spacing1 = baseSpacing * (1.0 + timeVar1 * 0.2);
    float spacing2 = baseSpacing * (1.0 + timeVar2 * 0.2);

    // float bandPosition1 = mod(diagonal - u_mouse.x * 1.5 + timeVar1, 2.0);
float bandPosition1 = mod(diagonal - u_mouse.x * u_mouse_sensitivity + timeVar1, 2.0);
    float bandPosition2 = mod(diagonal - u_mouse.x * 1.5 + spacing1 + timeVar2, 2.0);
    float bandPosition3 = mod(diagonal - u_mouse.x * 1.5 + spacing1 + spacing2 + timeVar3, 2.0);

    // Slightly randomize band widths
    float bandWidth = 0.1 + easeInSine(u_mouse.y) * 0.35;
    float bandWidth1 = bandWidth * (1.0 + timeVar1 * 0.15);
    float bandWidth2 = bandWidth * (1.0 + timeVar2 * 0.15);
    float bandWidth3 = bandWidth * (1.0 + timeVar3 * 0.15);

    // Calculate shine for each band with their individual widths
    float shine1 = smoothstep(-bandWidth1, 0.0, bandPosition1) * smoothstep(bandWidth1, 0.0, bandPosition1);
    float shine2 = smoothstep(-bandWidth2, 0.0, bandPosition2) * smoothstep(bandWidth2, 0.0, bandPosition2);
    float shine3 = smoothstep(-bandWidth3, 0.0, bandPosition3) * smoothstep(bandWidth3, 0.0, bandPosition3);

    // Can set different colors for each band, these numbers suck right now. Can change for all rgbs, and alpha, etc
    vec3 shine1color = vec3(sin(u_time + 0) * 0.8, 1.0, 1.2);
    vec3 shine2color = vec3(sin(u_time + 1) * 0.8, 1.0, 1.2);
    vec3 shine3color = vec3(sin(u_time + 2) * 0.8, 1.0, 1.2);

    // Combine all three shine effects
    vec3 shine = shine1 * shine1color + shine2 * shine2color + shine3 * shine3color;

    float brightness = dot(baseColor.rgb, vec3(0.299, 0.587, 0.114));
    vec3 finalShine = shine * u_intensity * brightness;

    float shineMask = step(0.2, brightness);
    finalShine *= shineMask;

    return vec4(baseColor.rgb + finalShine, baseColor.a);
}



vec4 position(mat4 transform_projection, vec4 vertex_position)
{
  if (u_mouse.x < 0.0) {
    return transform_projection * vertex_position;
  }

  // Temporary usage to prevent warnings
  vec2 temp = u_resolution * 0.0;

  // Work relative to the card's center
  vec2 localCenter = u_resolution / 2.0;
  float x = vertex_position.x - localCenter.x;
  float y = vertex_position.y - localCenter.y;

  // Tilt angles - tilt away from mouse position
  float tiltStrength = 0.2;
  float tiltX = -(u_mouse.y - 0.5) * tiltStrength;
  float tiltY = (u_mouse.x - 0.5) * tiltStrength;

  // Apply 3D rotations WITHOUT perspective shifting
  float z = 0.0;

  // X rotation
  float cosX = cos(tiltX);
  float sinX = sin(tiltX);
  float y2 = y * cosX;  // Remove z interaction

  // Y rotation
  float cosY = cos(tiltY);
  float sinY = sin(tiltY);
  float x3 = x * cosY;  // Remove z interaction

  // Put back to center WITHOUT perspective scaling
  vertex_position.x = x3 + localCenter.x + temp.x;
  vertex_position.y = y2 + localCenter.y;

  return transform_projection * vertex_position;
}
