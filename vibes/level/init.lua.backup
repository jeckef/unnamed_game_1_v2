local Random = require "vibes.engine.random"
local json = require "vendor.json"

local random = Random.new { name = "level-manager" }

local SpawnEntry = require "vibes.enemy.spawn-entry"
local Wave = require "vibes.enemy.wave"

---@alias DecorationName "water-tower" | "cave-down" | "cave-left" | "cave-right"

---@class vibes.LevelData.Decoration
---@field name DecorationName
---@field cell vibes.InlinedCell

---@class vibes.LevelData.PathSegment
---@field cell vibes.InlinedCell

---@class vibes.LevelData.Path
---@field segments vibes.LevelData.PathSegment[]
---@field id string
---@field type "hard"

---@class vibes.LevelData.NonPlaceableArea
---@field cell vibes.InlinedCell

---@class vibes.LevelData.EnhancementPercent
---@field enhancement string
---@field percent number

---@class vibes.LevelData.Spawn
---@field type EnemyType
---@field hp integer
---@field delay integer
---@field time_betwixt integer
---@field enhancements? vibes.LevelData.EnhancementPercent[]
---@field path_id string

---@class vibes.LevelData.Wave
---@field spawns vibes.LevelData.Spawn[]

---@class vibes.LevelData.Enhancement
---@field name string
---@field percent number

---@class vibes.LevelData.TextureCell
---@field tile "grass" | "path" | "empty"
---@field row integer
---@field col integer

---@class vibes.LevelData
---@field level integer
---@field name string
---@field textures vibes.LevelData.TextureCell[][]
---@field paths vibes.LevelData.Path[]
---@field non_placeable_areas vibes.LevelData.NonPlaceableArea[]
---@field waves vibes.LevelData.Wave[]
---@field decorations? vibes.LevelData.Decoration[]

---@class vibes.Level.Buff
---@field name string
---@field icon vibes.Texture
---@field value number

---@class vibes.Level.Opts
---@field level_data_path string
---@field fast_perlin_period? number
---@field slow_perlin_period? number

---@class (exact) vibes.Level
---@field new fun(opts: vibes.Level.Opts): vibes.Level
---@field init fun(self: vibes.Level, opts: vibes.Level.Opts)
---@field id string
---@field name string
---@field level_idx number
---@field paths vibes.Path[]
---@field cells vibes.Cell[][]
---@field waves enemy.Wave[]
---@field decorations vibes.LevelData.Decoration[]
---@field captcha_fail_stacks number
---@field fast_perlin_period number
---@field slow_perlin_period number
--
-- Fields that can be overridden by particular level instances
---@field on_start fun(self: vibes.Level)
---@field on_draw fun(self: vibes.Level)
---@field on_play fun(self: vibes.Level)
---@field on_wave fun(self: vibes.Level, wave: enemy.Wave)
---@field on_spawn fun(self: vibes.Level, wave: enemy.Wave, enemy: vibes.Enemy)
---@field on_end fun(self: vibes.Level)
---@field on_complete fun(self: vibes.Level)
---@field get_enemy_operations fun(self: vibes.Level, enemy: vibes.Enemy): enemy.StatOperation[]
---@field get_tower_operations fun(self: vibes.Level, tower: vibes.Tower): tower.StatOperation[]
---@field on_game_over fun(self: vibes.Level)
--
-- Parent methods, can be overridden by child classes if necessary
---@field init_map_data_from_file fun(self: self, file_path: string)
--
---@field _column_draw_order table<number, number[]>
local Level = class("vibes.Level", {})

---@param opts vibes.Level.Opts
function Level:init(opts)
  validate(opts, {
    level_data_path = "string",
    fast_perlin_period = "number?",
    slow_perlin_period = "number?",
  })

  self.id = "level-" .. opts.level_data_path
  self.captcha_fail_stacks = 0
  self:init_map_data_from_file(opts.level_data_path)
end

---@param offset_x number
---@param offset_y number
---@param r number
---@param c number
---@param period number
---@return number
local function get_noise_offset(offset_x, offset_y, r, c, period)
  return love.math.noise(r / period + offset_y, c / period + offset_x)
end

function Level:init_map_data_from_file(file_path)
  -- Load and parse the JSON file
  local level_json = assert(love.filesystem.read(file_path))
  local level_name = file_path:gsub(".json", ""):gsub("assets/level-json/", "")

  local TilesetOverdrawn = require "vibes.data.tileset-overdrawn"
  local overdrawn_sprites =
    TilesetOverdrawn.load_overdrawn_spritesheet "tileset-36.png"

  --- @type vibes.LevelData
  local level_data = json.decode(level_json)
  local level_index = level_data.level

  end

  local perlin_offset_x = math.floor(random:random() * 1000000)
  local perlin_offset_y = math.floor(random:random() * 1000000)

  ---@type vibes.Cell[][]
  local cells = {}
  for r = -4, Config.grid.grid_height + 5 do
    local row = {}
    cells[r] = row

    for c = -4, Config.grid.grid_width + 5 do
      local cell = Cell.new(r - 1, c - 1)
      --- @type vibes.LevelData.TextureCell
      local texture_info = (level_data.textures[r] or {})[c]
      if texture_info then
        local noise_offset =
          get_noise_offset(perlin_offset_x, perlin_offset_y, r, c, 40)
        local texture = assert(
          TilesetOverdrawn.get_random_tile_from_level_tile(
            overdrawn_sprites,
            texture_info,
            level_index,
            noise_offset
          ),
          "unable to load texture"
        )

        cell.texture = texture
        if texture_info.tile == "path" then
          cell.is_path = true
        end
      end
      cells[r][c] = cell
    end
  end

  ---@type table<string, vibes.Path>
  local paths = {}

  for _, path in pairs(level_data.paths or {}) do
    local cells = {}
    for _, segment in ipairs(path.segments or {}) do
      -- local cell = assert(cells[segment.cell.row + 1][segment.cell.col + 1], "path must exist")
      table.insert(cells, Cell.new(segment.cell.row, segment.cell.col))
    end

    assert(#path.segments > 0, "path must have segments")
    paths[path.id] = Path.new {
      cells = cells,
      id = path.id,
    }
  end

  -- Mark all cells that enemies will actually traverse as non-placeable
  for _, path in pairs(paths) do
    local traversed_cells = path:get_all_traversed_cells()
    for _, traversed_cell in ipairs(traversed_cells) do
      local r = traversed_cell.row + 1
      local c = traversed_cell.col + 1
      if cells[r] and cells[r][c] then
        cells[r][c].is_placeable = false
        cells[r][c].is_path = true
      end
    end
  end

  for _, area in ipairs(level_data.non_placeable_areas or {}) do
    local cell_row = assert(cells[area.cell.row + 1], "row must exist")
    local cell = assert(cell_row[area.cell.col + 1], "col must exist")
    cell.is_placeable = false
  end

  -- Double check that all cells have a texture and are initialized
  for r = 1, Config.grid.grid_height do
    for c = 1, Config.grid.grid_width do
      assert(cells[r][c], "Cell not initialized")
      assert(cells[r][c].texture, "has texture")
    end
  end

  local decoration_data =
    assert(level_data.decorations, "decorations must exist")
  local decorations = {}
  for _, decor in ipairs(decoration_data) do
    local decoration = {
      cell = cells[decor.cell.row + 1][decor.cell.col + 1],
      name = decor.name,
    }
    table.insert(decorations, decoration)
  end

  local waves = {}
  for _, wave in ipairs(level_data.waves) do
    local spawns = {}
    for _, spawn in ipairs(wave.spawns) do
      local path = assert(paths[spawn.path_id], "path must exist")
      local spawn_entry = SpawnEntry.new {
        path = path,
        spawn = spawn,
        level_idx = level_index,
      }
      table.insert(spawns, spawn_entry)
    end

    table.insert(waves, Wave.new { spawns = spawns })
  end

  self.name = level_name
  self.paths = paths
  self.cells = cells
  self.waves = waves
  self.decorations = decorations
  self.level_idx = level_data.level
end

function Level:draw()
  local minFilter, magFilter, anisotropy = love.graphics.getDefaultFilter()
  love.graphics.setDefaultFilter("nearest", "nearest")
  love.graphics.setColor(1, 1, 1, 1)

  -- Draw all non-path tiles first
  local rows = Config.grid.grid_height
  local cols = Config.grid.grid_width

  if not self._column_draw_order then
    self._column_draw_order = {}

    for rIdx = 1, rows do
      -- local available_columns = table.range(1, cols)
      -- table.shuffle(available_columns)
      -- self._column_draw_order[rIdx] = available_columns

      -- First, we need to get all the columns that are path tiles
      -- and separate them from the background tiles
      local path_columns, bg_columns = {}, {}
      for cIdx = 1, cols do
        if self.cells[rIdx][cIdx].is_path then
          table.insert(path_columns, cIdx)
        else
          table.insert(bg_columns, cIdx)
        end
      end

      -- Shuffle the background tiles, to give us a varied z-index look there
      table.shuffle(bg_columns)

      -- Put the path tiles first, then the background tiles
      -- This means the path tiles ALWAYS get drawn before the background tiles,
      -- which makes them creep OVER the path, which we think looks nice.
      table.list_extend(path_columns, bg_columns)

      -- Now save this order for later, so that we ALWAYS draw it the same
      -- way for this level (if you calculate it more often, it will be look scuffed)
      self._column_draw_order[rIdx] = path_columns
    end
  end

  local TilesetOverdrawn = require "vibes.data.tileset-overdrawn"
  for rIdx = 1, rows do
    for _, column in ipairs(self._column_draw_order[rIdx]) do
      local cell = self.cells[rIdx][column]
      if cell and cell.texture then
        TilesetOverdrawn.draw(cell)
      end
    end
  end

  -- Hours of debugging can save minutes of reading documents
  for _, cave in ipairs(self.decorations) do
    local texture_name = "water_tower"
    if cave.name == "cave-down" then
      texture_name = "cave_grass_down"
    elseif cave.name == "cave-left" then
      texture_name = "cave_grass_side"
    elseif cave.name == "cave-right" then
      texture_name = "cave_grass_side"
    end

    --- @type vibes.Texture
    local texture = Asset.sprites[texture_name]

    local x = cave.cell.col * Config.grid.cell_size
    local y = cave.cell.row * Config.grid.cell_size

    if texture_name == "water_tower" then
      local overscale = 2
      local scale_x = texture:getWidth() / Config.grid.cell_size * overscale
      local scale_y = texture:getHeight() / Config.grid.cell_size * overscale
      local scale = math.max(scale_x, scale_y)

      x = x
      y = y - Config.grid.cell_size * 3 / 2

      love.graphics.draw(texture, x, y, 0, scale, scale)
    else
      local overscale = 1.5
      local scale_x = texture:getWidth() / Config.grid.cell_size * overscale
      local scale_y = texture:getHeight() / Config.grid.cell_size * overscale

      if cave.name == "cave-left" then
        scale_x = -scale_x
        x = x + Config.grid.cell_size * overscale + 5
        y = y - Config.grid.cell_size * overscale - 20
      elseif cave.name == "cave-right" then
        -- scale_y = -scale_y
        x = x + Config.grid.cell_size * overscale + 5
        y = y - Config.grid.cell_size * overscale - 20
      elseif cave.name == "cave-down" then
        scale_x = -scale_x
      end
      love.graphics.draw(texture, x, y, 0, scale_x, scale_y)
    end
  end

  -- Reset color
  love.graphics.setColor(1, 1, 1, 1)

  love.graphics.setDefaultFilter(minFilter, magFilter, anisotropy)
end

function Level:on_start() end
function Level:on_draw() end
function Level:on_play() end

function Level:on_end() end
function Level:on_complete() end

function Level:on_game_over() end

--- @param wave enemy.Wave
--- @param enemy vibes.Enemy
function Level:on_spawn(wave, enemy) end

--- @param wave enemy.Wave
function Level:on_wave(wave) end

--- @return enemy.StatOperation[]
function Level:get_enemy_operations(_enemy)
  local ops = {}

  if (self.captcha_fail_stacks or 0) > 0 then
    local EnemyStatOperation = require "vibes.data.enemy-stats-operation"
    local StatOperation = require "vibes.data.stat-operation"
    local EnemyStatField = require "vibes.enum.enemy-stat-field"

    local factor = 1.25 ^ (self.captcha_fail_stacks or 0)
    table.insert(
      ops,
      EnemyStatOperation.new {
        field = EnemyStatField.SPEED,
        operation = StatOperation.mul_mult(factor),
      }
    )
  end

  return ops
end

--- @return tower.StatOperation[]
function Level:get_tower_operations(_tower) return {} end

return Level
